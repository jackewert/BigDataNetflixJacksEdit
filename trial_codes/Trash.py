ClusterMovieIDs = []
for CurrenMovieID in ClusterMovieIDs:
    # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    # UserRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
    count = count + 1
    CurrentMovieRatings = Mine_Ratings(CurrenMovieID, True, UserMovieData)
    MovieRatings = CurrentMovieRatings[1]
    # Evaluating all the movie statistics

    MovieMeanRating = np.nanmean(MovieRatings)
    MovieMaxRating = np.nanargmax(MovieRatings)
    MovieMinRating = np.nanargmin(MovieRatings)
    MovieStdDev = np.nanstd(MovieRatings)

    ElapsedTime = time.time() - StartTime
    print(count, ': Current User ID#', CurrenMovieID, '\t Time elapsed: ', ElapsedTime, ' seconds.')

    # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
    KnownMovieRatings = np.append(KnownMovieRatings, MovieRatings)

    ## Add up the number of users rating the current movie. This feature might be used to figure out how to
    ## distribute the load among cores.
    CurrentUserMovieCount = len(MovieRatings)
    # KnownUserRatingsCount = np.append(KnownUserRatingsCount, CurrentUserRatingsCount)

    # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
    # for now that will be the simplest approach).
    # This average reading will be the give for all users regardless.
    # Movie Stats are: MovieID, UserMeanRating, UserMaxRating, UserMinRating, UserStdDev

    # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
    # Repeating the same values for all ratings
    PredictedMovieRatings = np.append(PredictedMovieRatings, np.repeat(MovieRatings,
                                                                       CurrentUserMovieCount))

