'''
Name        : _Naive_Approach_Main.py
Version     : 1.0a
Author      : Alpaca (Waddah)

Input: None
Intermediates:
    All other functions in this module
Output: 0 or 1 (successful or failed run)

Details:
** The ultimate purpose for this is to find minimize RMSE for each cluster.
'''

'''
This function will go through the step of trying to investigate the right model for a Naive Appraoch
It will evaluate the RMSE for all the movies of a cluster (between actual and predicted ratings). 
It will choose a different model and calculate RMSE until it is below a certain threshold, then it will stop search
For now, this will be based on Movie Clustered based on Genres, Run Time and Year features. 

The next step is to integrate with user-clustered data. 
'''

import sys                 # to include current direction in the working directory
import os
import statistics
import numpy as np
np.set_printoptions(threshold=np.inf)    # to print entire output of numpy array
from math import sqrt
import time
from sklearn.metrics import mean_squared_error
from joblib import Parallel, delayed
import multiprocessing as mp
from itertools import product

#================importing other functions that generate
from Mine_Cluster_Movie_IDs import *
from Mine_Cluster_Users_IDs import *
from Mine_Dict_Movie_Ratings import *
# from Mine_Dict_User_Ratings import *
from GenerateSingleMovieRatingStats import *
from GenerateSingleUserRatingStats import *
# from RMSE_Ratings import *
from ProbeUserIDs import *

#=======================================================================================================================
def Mine_Ratings(DesiredID, InEpoch=True, UserMovieData = {}):
    '''
    This module was repurposed to work with both movies and user IDs, and integrated to avoid opening and closing
    files all the time
    File format is:
    UserID: MovieID 1 | Date 1 | Rating 1, MovieID 2 | Date 2 | Rating 2, ..., \n
    OR
    MovieID: UserID 1| Date 1| Rating 1, ... etc.

    Each Information is on a single currentLine.
    '''
    Ratings = []
    MovieIDs = []    # Can be used to create keys, but not the focus right now
    Dates = []

    # Use "in" function to search since it is the fastest way to search
    if DesiredID in UserMovieData:
        DesiredUserMovieData = UserMovieData[DesiredID]
        # print('User Ratings Found')
        # print('For User ID:', DesiredUserID, ', the movie ratings are: (MovieID|YYYY-MM-DD|Rating): \n', DesiredUserMovieData)

        AllData = DesiredUserMovieData.split(',')
        #print('All Movie Data Here Split into an Array: \n',AllData)

        for CurrentMovie in AllData:
            #(Movie ID|Date|Rating)
            CurrentData = CurrentMovie.split('|')

            Ratings.append(int(CurrentData[2]))
            CurrentDate = CurrentData[1]

            if InEpoch:
                DateRatedFormat = '%Y-%m-%d'
                DateRatedEpoch = int(time.mktime(time.strptime(CurrentDate, DateRatedFormat)))
                Dates.append(DateRatedEpoch)
            else:
                Dates.append(CurrentDate)


    else:
        print('User Ratings Not Found')

    return DesiredID, Ratings, Dates

#================================================================================================================================================
def main():
    # Next step is to look through all clusters?
    # Note: first cluster is cluster #0

    # Desired Movie Cluster Number
    DesiredMovieClusterNumber = 10
    # Desired UserCluster Number
    DesiredUserClusterNumber = 9




    # Starting a timer to evaluate how long the process lasts
    StartTime = time.time()


    print('--------------------Movie Cluster Modeling *Started*--------------------')
    KnownMovieRatings = np.array([])
    PredictedMovieRatings = np.array([])
    KnownMovieRatingsCount = np.array([])

    # # 1.1 Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    ClusterMovieIDs = np.array(Mine_Cluster_Movie_IDs(DesiredClusterNumber=1))
    ClusterMoviesCount = len(ClusterMovieIDs)
    print('There are', ClusterMoviesCount, 'users in Movie Cluster #', DesiredMovieClusterNumber)
    print('Finding the ratings for each user of each movie in the movie cluster...IN PROGRESS.\n')

    print('--------------------Movie Cluster Modeling *Started*--------------------')
    KnownMovieRatings = np.array([])
    PredictedMovieRatings = np.array([])
    KnownMovieRatingsCount = np.array([])
#
    count = 0

    MovieRatings = []
    UserIDs = []  # Can be used to create keys, but not the focus right now
    MovieDates = []

    fileName = '../data/movieIDDict.csv'
    # open the file
    FileHeader = open(fileName, 'r')

    # Generating Keys and Data
    MovieUserData = {}
    with open(fileName) as fileHeader:
        for currentLine in fileHeader:
            # userID = userID: movie Data is (Movie ID|Date|Rating)
            (movieID, userData) = currentLine.split(':')
            MovieUserData[int(movieID)] = userData


    ## No Parallel Processing

    for CurrentMovieID in ClusterMovieIDs:
        # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
        # UserRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
        CurrentMovieRatings = Mine_Dict_Movie_Ratings(CurrentMovieID, InEpoch=True)

        # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
        KnownMovieRatings = np.append(KnownMovieRatings, CurrentMovieRatings[1])

        # # Add up the number of users rating the current movie
        CurrentMovieRatingsCount = len(CurrentMovieRatings[1])
        # KnownMovieRatingsCount = np.append(KnownMovieRatingsCount, CurrentMovieRatingsCount)


        # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
        # for now that will be the simplest appraoch).
        # This average reading will be the give for all users regardless.
        # Movie Stats are: MovieID, UserMeanRating, UserMaxRating, UserMinRating, UserStdDev
        CurrentMovieStats = GenerateSingleMovieRatingStats(CurrentMovieID)

        # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
        # Repeating the same values for all ratings
        PredictedMovieRatings = np.append(PredictedMovieRatings, np.repeat(CurrentMovieStats[1],CurrentMovieRatingsCount))  # CurrentMovieMean = CurrentMovieStats[1]


    # 5. Calculate the RMSE for each movie, from RMSE(KNOWN Rating, Predicted Rating).

    CurrentMovieClusterRMSE = sqrt(mean_squared_error(KnownMovieRatings,PredictedMovieRatings))
    print('RMSE for Movie Cluster #', DesiredUserClusterNumber, 'is: ', CurrentMovieClusterRMSE)
    #
    # # 6. Make a choice about whether to accept that rating or not.
    # # return 0


    # # Parallel processing
    # print('--------------------Movie Parallel Processing *Started*--------------------')
    # #
    # # Figuring out the number of cores in this PC
    # num_cores = mp.cpu_count()
    # print('This computer has', num_cores, 'cores.')
    # poolProcesses = mp.Pool(processes=num_cores)
    #
    # movieChunkSize = ClusterMoviesCount / num_cores
    #
    # print('Total number of movies in cluster = ', ClusterMoviesCount)
    # print('Size of movies per chunk', movieChunkSize)
    #
    #
    # # with poolProcesses as pool:
    # #     AllMovieRatingsData = pool.starmap_async(Mine_Ratings,[(CurrentUserID, True, MovieUserData) for CurrentUserID in MovieUserData], movieChunkSize)
    # #     print('map async process finished')
    # # print('All movie ratings data:  ', AllMovieRatingsData.__dict__)
    #
    # # This works but it does not maximize the processor work
    # results = poolProcesses.apply_async(Mine_Ratings, args=[(CurrentUserID, True, MovieUserData) for CurrentUserID in MovieUserData])
    # print('Parallel job sent and currently waiting for it to be back...')
    # results.wait()     # wait until all results are back from the cover
    # print('Results are back from the pool!')
    # print(results.get())    # Printing th results after they are ready.
    #
    # # # results = [poolProcesses.map(Mine_Dict_User_Ratings(CurrentUserID, True, UserMovieData)) for CurrentUserID in ClusterUserIDs]
    # # # print(results)
    # #
    # # results = [poolProcesses.apply_async(Mine_Ratings, args=(CurrentUserID, True, MovieUserData)) for
    # #            CurrentUserID in ClusterMovieIDs]
    # # AllMovieRatingsData = [p.get() for p in results]
    #
    # # print('Parallel processing output for movie clusters are: \n', AllMovieRatingsData)
    # # print('--------------------Movie Parallel Processing *Ended*--------------------')



    # 7. Closing the dictionary file
    FileHeader.close()

    # Ending the process. Ending Timer
    ElapsedTime = time.time() - StartTime
    print('Time elapsed: ', ElapsedTime, ' seconds.')
    print('--------------------Finishing Movie Clustering Modeling process--------------------')

    #
    return 0


    print('--------------------User Cluster Modeling *Started*--------------------')
    KnownUserRatings = np.array([])
    PredictedUserRatings = np.array([])
    KnownUserRatingsCount = np.array([])

    # 1.2 Mining User IDs in a given cluster label generated from UserIDclusters.csv
    # 1.1 Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    ClusterUserIDs = np.array(Mine_Cluster_User_IDs(DesiredUserClusterNumber))

    print('There are', len(ClusterUserIDs), 'users in Cluster #', DesiredUserClusterNumber)

    count = 0

    UserRatings = []
    MovieIDs = []    # Can be used to create keys, but not the focus right now
    MovieDates = []

    fileName = '../data/customerIDDict.csv'
    # open the file
    FileHeader = open(fileName, 'r')

    # Generating Keys and Data
    UserMovieData = {}
    with open(fileName) as fileHeader:
        for currentLine in fileHeader:
            # userID = userID: movie Data is (Movie ID|Date|Rating)
            (userID, movieData) = currentLine.split(':')
            UserMovieData[int(userID)] = movieData

    # Parallel processing
    print('--------------------User Parallel Processing *Started*--------------------')
    #
    # Figuring out the number of cores in this PC
    num_cores = mp.cpu_count()
    print('This computer has', num_cores, 'cores.')


    # pool = mp.Pool(num_cores)

    poolProcesses = mp.Pool(processes=num_cores-1)

    # This works but it does not maximize the processor work
    results = [poolProcesses.apply(Mine_Dict_User_Ratings, args=(CurrentUserID, True, UserMovieData)) for CurrentUserID in ClusterUserIDs]
    print(results)

    # results = [poolProcesses.map(Mine_Dict_User_Ratings(CurrentUserID, True, UserMovieData)) for CurrentUserID in ClusterUserIDs]
    # print(results)

    # results = [poolProcesses.apply_async(Mine_Ratings, args=(CurrentUserID, True, UserMovieData)) for CurrentUserID in ClusterUserIDs]
    # AllUserRatingsData = [p.get() for p in results]

    print('Parallel processing output', AllUserRatingsData)
    print('--------------------User Parallel Processing *Ended*--------------------')


    for CurrentUserID in ClusterUserIDs:
        # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
        # UserRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
        count = count + 1
        CurrentUserRatings = Mine_Ratings(CurrentUserID, True, UserMovieData)
        UserRatings = CurrentUserRatings[1]
        # Evaluating all the movie statistics

        UserMeanRating = np.nanmean(UserRatings)
        UserMaxRating = np.nanargmax(UserRatings)
        UserMinRating = np.nanargmin(UserRatings)
        UserStdDev = np.nanstd(UserRatings)

        ElapsedTime = time.time() - StartTime
        print(count, ': Current User ID#', CurrentUserID, '\t Time elapsed: ', ElapsedTime, ' seconds.')

        # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
        KnownUserRatings = np.append(KnownUserRatings, UserRatings)

        ## Add up the number of users rating the current movie. This feature might be used to figure out how to
        ## distribute the load among cores.
        CurrentUserRatingsCount = len(UserRatings)
        # KnownUserRatingsCount = np.append(KnownUserRatingsCount, CurrentUserRatingsCount)

        # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
        # for now that will be the simplest approach).
        # This average reading will be the give for all users regardless.
        # Movie Stats are: MovieID, UserMeanRating, UserMaxRating, UserMinRating, UserStdDev


        # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
        # Repeating the same values for all ratings
        PredictedUserRatings = np.append(PredictedUserRatings, np.repeat(UserRatings,
                                                                         CurrentUserRatingsCount))  # CurrentMovieMean = CurrentMovieStats[1]


    # print('Known Movie Ratings: ', KnownMovieRatings)
    # print('Predicted Movie Ratings: ', PredictedMovieRatings)
    # print('Number of Known Ratings per movie:', KnownMovieRatingsCount)



    # 5. Calculate the RMSE for each movie, from RMSE(KNOWN Rating, Predicted Rating).

    CurrentUserClusterRMSE = sqrt(mean_squared_error(KnownUserRatings,PredictedUserRatings))
    print('RMSE for User Cluster #', DesiredUserClusterNumber, 'is: ', CurrentUserClusterRMSE)

    # 6. Make a choice about whether to accept that rating or not.
    # return 0

    # 7. Closing the dictionary file
    FileHeader.close()

    # Ending the process. Ending Timer
    ElapsedTime = time.time() - StartTime
    print('Time elapsed: ', ElapsedTime, ' seconds.')
    print('--------------------Finishing the process--------------------')
    #

    print('--------------------Shutting down the the process--------------------')
    poolProcesses.terminate()














if __name__ == "__main__":
    main()






'''

Code relegated to the past:



    # for CurrentMovieID in ClusterMovieIDs:
    #     # 1. Mine the Movie IDs in a given cluster label from MovieIDclusters.csv generated by ______________________
    #     # UserRatings are: MovieID, Ratings (Array), Date (Epoch or not) (Array)
    #     CurrentMovieRatings = Mine_Dict_Movie_Ratings(CurrentMovieID, InEpoch=True)
    #
    #     # Look up the *KNOWN RATINGS* for the current movie ID and Appending to other movie ratings in this cluster
    #     KnownMovieRatings = np.append(KnownMovieRatings, CurrentMovieRatings[1])
    #
    #     # # Add up the number of users rating the current movie
    #     CurrentMovieRatingsCount = len(CurrentMovieRatings[1])
    #     # KnownMovieRatingsCount = np.append(KnownMovieRatingsCount, CurrentMovieRatingsCount)
    #
    #
    #     # 3. Calculate the average *PREDICTED Ratings* for movies in that cluster (
    #     # for now that will be the simplest appraoch).
    #     # This average reading will be the give for all users regardless.
    #     # Movie Stats are: MovieID, UserMeanRating, UserMaxRating, UserMinRating, UserStdDev
    #     CurrentMovieStats = GenerateSingleMovieRatingStats(CurrentMovieID)
    #
    #     # Using the mean of the ratings for now as the Predicted Movie Rating. No adjustment for individual users yet.
    #     # Repeating the same values for all ratings
    #     PredictedMovieRatings = np.append(PredictedMovieRatings, np.repeat(CurrentMovieStats[1],CurrentMovieRatingsCount))  # CurrentMovieMean = CurrentMovieStats[1]


    # print('Known Movie Ratings: ', KnownMovieRatings)
    # print('Predicted Movie Ratings: ', PredictedMovieRatings)
    # print('Number of Known Ratings per movie:', KnownMovieRatingsCount)





  #
    #
    # # 5. Calculate the RMSE for each movie, from RMSE(KNOWN Rating, Predicted Rating).
    # CurrentMovieClusterRMSE = RMSE_Ratings(KnownMovieRatings,PredictedMovieRatings)
    # print('RMSE for Movie Cluster #', DesiredMovieClusterNumber, 'is: ', CurrentMovieClusterRMSE)
    # print('Finding the ratings for each movies of each user in the user cluster...IN PROGRESS.')
    #
    # ## 6. Make a choice about whether to accept that rating or not.
    # # return 0
    #
    # # Ending the process. Ending Timer
    # ElapsedTime = time.time() - StartTime
    # print('Time elapsed: ', ElapsedTime, ' seconds.')
    # print('--------------------Movie Cluster Modeling *Finished*--------------------')
'''